<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CYBERTECH:Biometric Fingerprinter</title>
    <!-- Подключаем пиксельный шрифт -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <!-- Подключаем библиотеку Tone.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    <style>
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            background-color: #0d1117;
            color: #c9d1d9;
            /* Применяем новый пиксельный шрифт */
            font-family: 'Press Start 2P', cursive;
            overflow: hidden;
        }

        /* Основной контейнер игры, который будет центрирован */
        .game-container {
            position: relative;
            text-align: center;
            background-color: #161b22;
            padding: 20px;
            border-radius: 0;
            border: 2px solid #30363d;
            box-shadow: none;
            width: 500px;
            /* Убрана фиксированная высота, чтобы контейнер подстраивался под содержимое */
            height: auto;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        /* Анимированный фон-сеточка для всего контейнера */
        .game-container::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image:
                linear-gradient(to right, #111 1px, transparent 1px),
                linear-gradient(to bottom, #111 1px, transparent 1px);
            background-size: 20px 20px;
            opacity: 0.1;
            pointer-events: none;
            z-index: 0;
            animation: pulse-grid 4s infinite alternate;
        }

        @keyframes pulse-grid {
            from { opacity: 0.05; }
            to { opacity: 0.2; }
        }
        
        #info-panel {
            text-align: left;
            font-size: 14px;
            line-height: 1.5;
            position: relative;
            z-index: 1;
            padding-top: 0;
            padding-bottom: 0;
            margin-bottom: 20px;
            margin-top: 0;
        }
        
        #info-panel p {
            margin: 0; 
            padding: 0;
            text-align: left;
        }

        /* Добавляем класс для плавного появления текста */
        .fade-in {
            opacity: 0;
            transition: opacity 0.5s ease;
        }
        
        .fade-in.visible {
            opacity: 1;
        }

        /* Canvas-wrapper теперь имеет фиксированный размер и центрируется */
        .canvas-wrapper {
            position: relative;
            width: 400px;
            height: 400px;
            margin: 0 auto;
            border: 2px solid #1b5d25; 
            transition: border 0.5s ease;
            z-index: 1;
        }

        .canvas-wrapper.active {
            border: 2px solid #2ea043;
        }

        #backgroundCanvas {
            position: absolute;
            top: 0;
            left: 0;
            z-index: 0;
            background-color: #000000;
            background-image: none;
            transition: background-image 0.5s ease;
        }
        
        #backgroundCanvas.grid-visible {
             background-image:
                linear-gradient(to right, rgba(35, 134, 54, 0.1) 1px, transparent 1px),
                linear-gradient(to bottom, rgba(35, 134, 54, 0.1) 1px, transparent 1px);
             background-size: 25px 25px; 
        }

        canvas {
            background-color: transparent;
            cursor: crosshair;
            image-rendering: pixelated;
            position: relative;
            z-index: 1; 
        }

        /* Стили для новой кнопки */
        #startButton, #exitButton {
            background-color: #161b22;
            color: #c9d1d9;
            border: 2px solid #30363d;
            font-family: 'Press Start 2P', cursive;
            padding: 10px 20px;
            font-size: 12px;
            cursor: pointer;
            z-index: 3;
            transition: background-color 0.2s, color 0.2s;
            letter-spacing: 1.5px;
            word-spacing: 5px;
            text-align: center;
        }
        
        #startButton {
             position: absolute;
             top: 50%;
             left: 50%;
             transform: translate(-50%, -50%);
        }

        #startButton:hover, #exitButton:hover {
            background-color: #30363d;
            color: #fff;
        }

        /* Стили для контейнера с подсказками */
        #tips-container {
            font-size: 14px;
            line-height: 1.5;
            padding: 10px;
            text-align: center;
            height: 50px;
            margin-bottom: 40px;
        }
        
        /* Стиль для мигающего текста */
        #cybertech-text {
            font-size: 12px;
            text-align: center;
            margin-top: 10px;
            animation: blink 1s infinite;
            cursor: pointer;
        }
        
        /* Скрытое сообщение */
        #secret-message {
            font-size: 12px;
            color: #2ea043;
            text-align: center;
            margin-top: 10px;
            display: none;
            word-break: break-all;
        }
        
        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0; }
        }

        .feedback-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            padding: 20px 40px;
            background-color: rgba(22, 27, 34, 0.95);
            border-radius: 0;
            font-size: 20px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s ease;
            text-align: center;
            z-index: 2;
        }

        .feedback-message.success {
            color: #2ea043;
            border: 2px solid #2ea043;
        }

        .feedback-message.failure {
            color: #f85149;
            border: 2px solid #f85149;
        }

        /* Теперь div-ы с таймером и попытками будут отображаться всегда */
        #timer-and-attempts {
            margin-top: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 14px;
            color: #c9d1d9;
        }
        
        .hidden {
            display: none !important;
        }

        /* Стиль для контейнера с сообщениями и кнопкой, размещенного внутри canvas-wrapper */
        #completion-message-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background-color: rgba(0, 0, 0, 0.8);
            z-index: 2;
        }

        #completion-message {
            font-size: 24px;
            color: #2ea043;
            margin-bottom: 10px;
            /* Начальное мигание */
            animation: blinker-standard 1s step-end infinite;
        }
        
        /* Новая анимация для стандартного мигания */
        @keyframes blinker-standard {
            50% {
                opacity: 0;
            }
        }

        /* Анимация для чередования текста */
        .alternating-text {
            animation: none !important;
        }
        
        #privilege-message {
            font-size: 16px;
            color: #c9d1d9;
            margin-bottom: 20px;
            animation: pulse-message 2s infinite;
        }

        @keyframes pulse-message {
            0% { opacity: 0.5; }
            50% { opacity: 1; }
            100% { opacity: 0.5; }
        }

        .reversed-text {
            unicode-bidi: bidi-override;
            direction: rtl;
        }
        
        /* Добавлен новый контейнер для центрирования и масштабирования */
        .outer-wrapper {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            width: 100vw;
        }
        
        /* Внутренний контейнер для масштабирования, который занимает только необходимое место */
        .inner-scale-wrapper {
            transform-origin: top center;
        }

    </style>
</head>
<body>
    <div class="outer-wrapper">
        <div class="inner-scale-wrapper">
            <div class="game-container">
                <!-- Контейнер с подсказками -->
                <div id="tips-container"></div>
            
                <!-- Инфо-панель -->
                <div id="info-panel" class="hidden">
                    <p class="fade-in" id="coding-text">> КОДИРОВКА: БИОМЕТРИЯ</p>
                    <p class="fade-in" id="object-text">> ОБЪЕКТ: МИЗИНЕЦ</p> 
                    <p class="fade-in" id="stage-text">> ЭТАП: 1/5</p>
                </div>
                
                <!-- Обертка для canvas и кнопки -->
                <div class="canvas-wrapper">
                    <canvas id="backgroundCanvas" width="400" height="400"></canvas>
                    <canvas id="gameCanvas" width="400" height="400"></canvas>
                    
                    <!-- Кнопка старта -->
                    <button id="startButton">АКТИВАЦИЯ ПРОТОКОЛА</button>

                    <!-- Экран завершения, теперь внутри canvas-wrapper -->
                    <div id="completion-message-container" class="hidden">
                        <p id="completion-message">АНАЛИЗ ЗАВЕРШЁН</p>
                        <p id="privilege-message" class="hidden"></p>
                        <button id="exitButton">ВЫЙТИ ИЗ СИМУЛЯЦИИ</button>
                    </div>

                </div>
                
                <!-- Мигающий текст -->
                <p id="cybertech-text">CYBERTECH</p>
                <!-- Скрытое сообщение -->
                <p id="secret-message"></p>
                
                <!-- Перемещенный div для отображения времени и попыток -->
                <div id="timer-and-attempts">
                    <p class="fade-in" id="attempts-display">ДОПУСК: 3</p>
                    <p class="fade-in" id="timer-display">ВРЕМЯ: 30 СЕК</p>
                </div>
                
                <div id="feedback" class="feedback-message"></div>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const bgCanvas = document.getElementById('backgroundCanvas');
        const bgCtx = bgCanvas.getContext('2d');
        const startButton = document.getElementById('startButton');
        const exitButton = document.getElementById('exitButton');
        const canvasWrapper = document.querySelector('.canvas-wrapper');
        const timerAndAttempts = document.getElementById('timer-and-attempts');
        const gameContainer = document.querySelector('.game-container');
        
        // Элементы текста
        const infoPanel = document.getElementById('info-panel');
        const codingText = document.getElementById('coding-text');
        const objectText = document.getElementById('object-text');
        const stageText = document.getElementById('stage-text');
        const attemptsDisplay = document.getElementById('attempts-display');
        const timerDisplay = document.getElementById('timer-display');
        const feedbackEl = document.getElementById('feedback');
        const innerScaleWrapper = document.querySelector('.inner-scale-wrapper');
        
        // Элементы для подсказок и мигающего текста
        const tipsContainer = document.getElementById('tips-container');
        const cybertechText = document.getElementById('cybertech-text');
        const secretMessage = document.getElementById('secret-message');
        const completionMessageContainer = document.getElementById('completion-message-container');
        const completionMessage = document.getElementById('completion-message');
        const privilegeMessage = document.getElementById('privilege-message');

        let tipsInterval;
        let blinkingInterval;
        
        // Переменная для отслеживания нажатий на "CYBERTECH"
        let cybertechClickCount = 0;
        let isReversed = false;
        let isCrazyMode = false;
        
        // Новая переменная для отслеживания идеального прохождения
        let perfectRun = true;
        
        // Вспомогательная функция для переворачивания строки
        function reverseString(str) {
            return str.split('').reverse().join('');
        }
        
        // Функция для обновления текста на всех элементах
        function updateAllText() {
            // Определяем количество попыток для отображения
            const displayAttempts = isCrazyMode ? attemptsLeft : (3 - attemptsLeft);
            // Корректное отображение этапа в зависимости от режима
            const displayStage = isCrazyMode ? (levels.length - currentLevel) : (currentLevel + 1);

            const elementsToUpdate = [
                { el: codingText, text: "> КОДИРОВКА: БИОМЕТРИЯ" },
                { el: objectText, text: `> ОБЪЕКТ: ${levelNames[currentLevel]}` },
                { el: stageText, text: `> ЭТАП: ${displayStage}/5` },
                { el: attemptsDisplay, text: `ДОПУСК: ${attemptsLeft}` },
                { el: timerDisplay, text: `ВРЕМЯ: ${timeLeft} СЕК` },
                { el: startButton, text: (currentLevel === 0 && !isCrazyMode) ? "АКТИВАЦИЯ ПРОТОКОЛА" : "ПРОДОЛЖИТЬ ТРАССИРОВКУ" },
                { el: exitButton, text: "ВЫЙТИ ИЗ СИМУЛЯЦИИ" },
            ];

            elementsToUpdate.forEach(item => {
                if (item.el) {
                    item.el.textContent = isReversed ? reverseString(item.text) : item.text;
                }
            });
            // Сообщение о завершении теперь управляется отдельной функцией, поэтому его здесь нет
        }
        
        // ------------------ ФУНКЦИИ ДЛЯ РАБОТЫ С ДВОИЧНЫМ КОДОМ ------------------
        function textToBinary(text) {
            return text.split('').map(char => {
                const binary = char.charCodeAt(0).toString(2);
                return '0'.repeat(16 - binary.length) + binary;
            }).join(' ');
        }
        
        // Функция для отображения двоичного кода с эффектом набора
        function showBinaryMessage() {
            const binaryMessage = textToBinary(welcomeMessage);
            const binaryChars = binaryMessage.split('');
            secretMessage.textContent = '';
            
            let index = 0;
            const typeInterval = setInterval(() => {
                if (index < binaryChars.length) {
                    secretMessage.textContent += binaryChars[index];
                    index++;
                } else {
                    clearInterval(typeInterval);
                }
            }, 50);
        }
        
        // ------------------ КОНЕЦ ФУНКЦИЙ ДЛЯ РАБОТЫ С ДВОИЧНЫМ КОДОМ ------------------
        
        // Базовые размеры, на основе которых происходит масштабирование
        const baseWidth = 500;
        let baseHeight; 
        const scalingMultiplier = 0.95; 
        
        // Определяем допуск для каждого уровня
        const levelTolerances = [10, 8, 7, 6, 5];
        // Устанавливаем время для каждого уровня на 30 секунд
        const levelTimes = [30, 30, 30, 30, 30];
        const nodeRadius = 20;
        
        // Массивы со случайными сообщениями
        const singleFailureMessages = ["СБОЙ", "ПРЕРВАНО", "ОШИБКА", "ОТКЛОНЕНО", "ДОПУСК ПОНИЖЕН", "НЕВЕРНЫЙ АНАЛИЗ", "НАРУШЕНИЕ КОДИРОВКИ"];
        const gameOverMessages = ["КРИТ.ОШИБКА", "ОТКАЗАНО В ДОСТУПЕ", "ЭТАП ПРОВАЛЕН", "ИДЕНТИФИКАЦИЯ НЕВОЗМОЖНА", "НЕТ ДОСТУПА", "НЕТ СИГНАЛА", "ДОСТУП ЗАПРЕЩЁН"];
        
        // Массив подсказок
        const tips = [
            "ВЫ МОЖЕТЕ ВЫБРАТЬ ЛЮБУЮ ИЗ ДВУХ ТОЧЕК ДЛЯ НАЧАЛА ТРАССИРОВКИ",
            "ИДЕАЛЬНАЯ ТРАССИРОВКА ДАЁТ ВАМ +3 СЕК ПРЕИМУЩЕСТВА НА СЛЕДУЮЩЕМ ЭТАПЕ",
            "НЕ БОЙТЕСЬ ОШИБИТЬСЯ.ВАМ ДАЁТСЯ 3 ДОПУСКА ДЛЯ ПРОХОЖДЕНИЯ ЭТАПА",
            "КАЖДЫЙ НОВЫЙ ЭТАП СЛОЖНЕЕ ПРЕДЫДУЩЕГО.СТАРАЙТЕСЬ ВЕСТИ ТОЧНУЮ ТРАССИРОВКУ",
            "ПРОЙДИТЕ ВСЕ ЭТАПЫ ИДЕАЛЬНО,ЧТОБЫ ПОЛУЧИТЬ ПРИВИЛЕГИЮ",
            "СТАРАЙТЕСЬ НЕ ОТВЛЕКАТЬСЯ.ТОЧНОСТЬ - ВАШ СОЮЗНИК",
            "НАСТОЯТЕЛЬНО РЕКОМЕНДУЕТСЯ НЕ НАЖИМАТЬ НА CYBERTECH" 
        ];

        // УЗОРЫ-ЛАБИРИНТЫ
        const levels = [
            [{x: 100, y: 100}, {x: 300, y: 100}, {x: 300, y: 300}, {x: 100, y: 300}, {x: 100, y: 150}, {x: 250, y: 150}, {x: 250, y: 250}, {x: 150, y: 250}, {x: 150, y: 200}],
            [{x: 50, y: 50}, {x: 350, y: 50}, {x: 350, y: 350}, {x: 50, y: 350}, {x: 50, y: 100}, {x: 300, y: 100}, {x: 300, y: 300}, {x: 100, y: 300}, {x: 100, y: 250}, {x: 250, y: 250}],
            [{x: 50, y: 50}, {x: 350, y: 50}, {x: 350, y: 350}, {x: 50, y: 350}, {x: 50, y: 100}, {x: 300, y: 100}, {x: 300, y: 300}, {x: 100, y: 300}, {x: 100, y: 150}, {x: 250, y: 150}, {x: 250, y: 200}],
            [{x: 50, y: 50}, {x: 350, y: 50}, {x: 350, y: 350}, {x: 50, y: 350}, {x: 50, y: 100}, {x: 300, y: 100}, {x: 300, y: 300}, {x: 100, y: 300}, {x: 100, y: 150}, {x: 250, y: 150}, {x: 250, y: 250}, {x: 150, y: 250}, {x: 150, y: 200}],
            [{x: 50, y: 50}, {x: 350, y: 50}, {x: 350, y: 350}, {x: 50, y: 350}, {x: 50, y: 100}, {x: 300, y: 100}, {x: 300, y: 300}, {x: 100, y: 300}, {x: 100, y: 150}, {x: 250, y: 150}, {x: 250, y: 250}, {x: 150, y: 250}, {x: 150, y: 200}, {x: 200, y: 200}]
        ];
        // Обновленные названия уровней
        const levelNames = ["МИЗИНЕЦ", "БЕЗЫМЯННЫЙ ПАЛЕЦ", "СРЕДНИЙ ПАЛЕЦ", "УКАЗАТЕЛЬНЫЙ ПАЛЕЦ", "БОЛЬШОЙ ПАЛЕЦ"];
        
        let currentLevel; // Переменная для текущего уровня
        let isTracing = false;
        let isGameOver = false;
        let isGameActive = false;
        let path, startNode, endNode, traceEndNode;
        let playerProgress = [];
        let attemptsLeft; // Количество оставшихся попыток
        let timeLeft = 0;
        let timerInterval;

        let animationFrameId;
        let startNodeColor = '#238636';
        let endNodeColor = '#238636';
        let circlePositions;

        let infoElementsVisible = false;
        
        // Строка для двоичного кода
        const welcomeMessage = "ДОБРО ПОЖАЛОВАТЬ В МИР АБСУРДА";
        
        // ------------------ ФУНКЦИИ ДЛЯ РАБОТЫ С ДВОИЧНЫМ КОДОМ ------------------
        function textToBinary(text) {
            return text.split('').map(char => {
                const binary = char.charCodeAt(0).toString(2);
                return '0'.repeat(16 - binary.length) + binary;
            }).join(' ');
        }
        
        // Функция для отображения двоичного кода с эффектом набора
        function showBinaryMessage() {
            const binaryMessage = textToBinary(welcomeMessage);
            const binaryChars = binaryMessage.split('');
            secretMessage.textContent = '';
            
            let index = 0;
            const typeInterval = setInterval(() => {
                if (index < binaryChars.length) {
                    secretMessage.textContent += binaryChars[index];
                    index++;
                } else {
                    clearInterval(typeInterval);
                }
            }, 50);
        }
        
        // ------------------ КОНЕЦ ФУНКЦИЙ ДЛЯ РАБОТЫ С ДВОИЧНЫМ КОДОМ ------------------
        
        // Массив из трех вариантов звука для ошибки
        const errorSounds = [
            { note: "C3", duration: "8n" },
            { note: "C#3", duration: "8n" },
            { note: "D3", duration: "8n" }
        ];

        const errorSynth = new Tone.Synth({
            oscillator: { type: "triangle" }, 
            envelope: {
                attack: 0.005,
                decay: 0.2,
                sustain: 0.1,
                release: 0.5,
            }
        }).toDestination();
        
        const gameOverSounds = [
            { notes: ["C2", "G1"], duration: "4n" },
            { notes: ["A1", "E2"], duration: "4n" }
        ];

        const gameOverSynth = new Tone.PolySynth(Tone.Synth, {
            oscillator: { type: "triangle" },
            envelope: {
                attack: 0.05,
                decay: 0.2,
                sustain: 0.1,
                release: 0.5,
            }
        }).toDestination();
        
        const buttonSounds = [
            { note: "C5", duration: "8n" },
            { note: "D#5", duration: "8n" },
            { note: "G5", duration: "8n" }
        ];

        const buttonSynth = new Tone.PluckSynth({
            attackNoise: 1,
            dampening: 4000,
            resonance: 0.9
        }).toDestination();

        const successCompositions = [
            { notes: ["C5"], durations: ["8n"] },
            { notes: ["G4"], durations: ["8n"] }
        ];

        const bonusCompositions = [
            { notes: ["C5"], durations: ["8n"] },
            { notes: ["G4"], durations: ["8n"] }
        ];

        const successSynth = new Tone.PolySynth(Tone.Synth, {
            oscillator: { type: "sine" },
            envelope: {
                attack: 0.01,
                decay: 0.1,
                sustain: 0.3,
                release: 0.5,
            }
        }).toDestination();

        function playSuccessSound() {
            const composition = successCompositions[Math.floor(Math.random() * successCompositions.length)];
            const now = Tone.now();
            composition.notes.forEach((note, index) => {
                const duration = composition.durations[index];
                successSynth.triggerAttackRelease(note, duration, now + Tone.Time("8n").toSeconds() * index);
            });
        }
        
        function playBonusSound() {
            const composition = bonusCompositions[Math.floor(Math.random() * bonusCompositions.length)];
            const now = Tone.now();
            composition.notes.forEach((note, index) => {
                const duration = composition.durations[index];
                successSynth.triggerAttackRelease(note, duration, now + Tone.Time("8n").toSeconds() * index);
            });
        }

        function drawPixelatedCircle(ctx, x, y, radius, color) {
            const step = Math.PI / (4 * radius);
            ctx.fillStyle = color;
            for (let a = 0; a < 2 * Math.PI; a += step) {
                const px = x + radius * Math.cos(a);
                const py = y + radius * Math.sin(a);
                ctx.fillRect(Math.floor(px), Math.floor(py), 3, 3);
            }
        }

        function startBackgroundAnimation() {
            let angle = 0;
            const circleSettings = [
                { num: 4, maxRadius: 150, pulseSpeed: 0.02, color: 'rgba(35, 134, 54, 0.1)' },
                { num: 6, maxRadius: 100, pulseSpeed: 0.03, color: 'rgba(35, 134, 54, 0.1)' },
                { num: 8, maxRadius: 120, pulseSpeed: 0.04, color: 'rgba(35, 134, 54, 0.1)' },
                { num: 10, maxRadius: 130, pulseSpeed: 0.05, color: 'rgba(35, 134, 54, 0.1)' },
                { num: 12, maxRadius: 150, pulseSpeed: 0.06, color: 'rgba(35, 134, 54, 0.1)' }
            ];

            const settings = circleSettings[currentLevel];
            
            circlePositions = [];
            for (let i = 0; i < settings.num; i++) {
                circlePositions.push({ x: 200, y: 200, angleOffset: Math.random() * Math.PI * 2 });
            }

            function animateBackground() {
                bgCtx.clearRect(0, 0, bgCanvas.width, bgCanvas.height);
                
                for (let i = 0; i < settings.num; i++) {
                    const circle = circlePositions[i];
                    const x = 200 + 150 * Math.sin(angle * 0.05 + circle.angleOffset);
                    const y = 200 + 150 * Math.cos(angle * 0.05 + circle.angleOffset);
                    const radius = settings.maxRadius * (0.5 + 0.5 * Math.sin(angle + i * 0.5));
                    
                    drawPixelatedCircle(bgCtx, x, y, radius, settings.color);
                }

                angle += settings.pulseSpeed;
                animationFrameId = requestAnimationFrame(animateBackground);
            }
            animateBackground();
        }

        function stopBackgroundAnimation() {
            cancelAnimationFrame(animationFrameId);
        }
        
        function startTips() {
            let lastTipIndex = -1;
            function showRandomTip() {
                let newIndex;
                do {
                    newIndex = Math.floor(Math.random() * tips.length);
                } while (newIndex === lastTipIndex);
                lastTipIndex = newIndex;
                tipsContainer.textContent = tips[newIndex];
                if (isReversed) {
                    tipsContainer.textContent = reverseString(tipsContainer.textContent);
                }
            }
            showRandomTip();
            tipsInterval = setInterval(showRandomTip, 4000);
        }

        function stopTips() {
            clearInterval(tipsInterval);
            tipsContainer.textContent = '';
        }

        function resizeGame() {
            const viewportWidth = window.innerWidth;
            const viewportHeight = window.innerHeight;

            const containerRect = gameContainer.getBoundingClientRect();
            const containerWidth = containerRect.width;
            const containerHeight = containerRect.height;
            
            // Расчет масштаба, чтобы игра умещалась в экран
            const scale = Math.min(viewportWidth / containerWidth, viewportHeight / containerHeight);

            // Применение масштаба ко всему игровому контейнеру
            innerScaleWrapper.style.transform = `scale(${scale})`;
        }


        window.addEventListener('load', () => {
            gameContainer.style.height = 'auto'; 
            resizeGame();
            startTips();
        });
        window.addEventListener('resize', () => {
            setTimeout(resizeGame, 100);
        });

        function showFeedback(message, type) {
            feedbackEl.innerHTML = isReversed ? reverseString(message) : message;
            feedbackEl.className = `feedback-message ${type}`;
            feedbackEl.style.opacity = '1';
            
            setTimeout(() => {
                feedbackEl.style.opacity = '0';
            }, 1500);
        }

        function createCurve(points) {
            const path = new Path2D();
            path.moveTo(points[0].x, points[0].y);
            
            for (let i = 0; i < points.length - 1; i++) {
                const xc = (points[i].x + points[i+1].x) / 2;
                const yc = (points[i].y + points[i+1].y) / 2;
                path.quadraticCurveTo(points[i].x, points[i].y, xc, yc);
            }
            
            path.lineTo(points[points.length - 1].x, points[points.length - 1].y);
            
            return path;
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            ctx.strokeStyle = '#30363d';
            ctx.lineWidth = 8;
            ctx.stroke(path);
            
            ctx.fillStyle = startNodeColor;
            ctx.beginPath();
            ctx.arc(startNode.x, startNode.y, nodeRadius, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = endNodeColor;
            ctx.beginPath();
            ctx.arc(endNode.x, endNode.y, nodeRadius, 0, Math.PI * 2);
            ctx.fill();

            if (playerProgress.length > 1) {
                ctx.strokeStyle = '#FFFFFF';
                ctx.lineWidth = 5;
                ctx.beginPath();
                ctx.moveTo(playerProgress[0].x, playerProgress[0].y);
                for (let i = 1; i < playerProgress.length; i++) {
                    ctx.lineTo(playerProgress[i].x, playerProgress[i].y);
                }
                ctx.stroke();
            }
        }
        
        // Логика таймера теперь зависит от режима
        function startTimer() {
            clearInterval(timerInterval);
            timerInterval = setInterval(() => {
                if (isCrazyMode) {
                    timeLeft++;
                    if (timeLeft >= 60) {
                         clearInterval(timerInterval);
                         handleFailure("TIME OUT");
                    }
                } else {
                    timeLeft--;
                    if (timeLeft <= 0) {
                        clearInterval(timerInterval);
                        handleFailure("TIME OUT");
                    }
                }
                updateAllText();
            }, 1000);
        }
        
        function resetGame() {
            currentLevel = 0;
            infoElementsVisible = false;
            isGameActive = false; 
            
            if (isReversed) {
                isReversed = false;
            }
            isCrazyMode = false;
            
            cybertechClickCount = 0; 
            cybertechText.addEventListener('click', handleCybertechClick);
            
            // Сброс флага идеального прохождения
            perfectRun = true;

            loadLevel(currentLevel);
            document.querySelectorAll('.fade-in').forEach(el => el.classList.remove('visible'));
            startTips();
            tipsContainer.classList.remove('hidden');
            cybertechText.classList.remove('hidden');
            secretMessage.style.display = 'none';
            secretMessage.textContent = '';
            infoPanel.classList.add('hidden');
            completionMessageContainer.classList.add('hidden');
            privilegeMessage.classList.add('hidden');
            timerAndAttempts.classList.remove('hidden'); 
            resizeGame(); 
        }

        // Добавляем параметр для бонусного времени
        function loadLevel(levelIndex, bonusTime = 0) {
            isGameOver = false;
            isGameActive = false; 
            
            // Количество попыток зависит от режима
            attemptsLeft = isCrazyMode ? 0 : 3;
            
            const levelData = levels[levelIndex];
            path = createCurve(levelData);
            startNode = levelData[0];
            endNode = levelData[levelData.length - 1];
            playerProgress = [];
            isTracing = false;
            startNodeColor = '#238636';
            endNodeColor = '#238636';

            // Начальное время зависит от режима и бонуса
            timeLeft = (isCrazyMode ? 30 : 30) + bonusTime;
            
            updateAllText();

            canvas.style.display = 'none';
            bgCanvas.style.display = 'none';
            canvasWrapper.classList.remove('active');
            bgCanvas.classList.remove('grid-visible');
            
            startButton.classList.remove('hidden');
            
            stopBackgroundAnimation();
        }

        function isInsideCircle(point, circle, radius) {
            const dx = point.x - circle.x;
            const dy = point.y - circle.y;
            return dx * dx + dy * dy < radius * radius;
        }

        function handleFailure(message) {
            isTracing = false;
            isGameActive = false;
            clearInterval(timerInterval);
            
            // Если была ошибка, то идеальное прохождение больше невозможно
            perfectRun = false;

            // Логика изменения попыток
            if (isCrazyMode) {
                 attemptsLeft++;
            } else {
                 attemptsLeft--;
            }

            let feedbackMessage;
            // Логика поражения
            if ((!isCrazyMode && attemptsLeft <= 0) || (isCrazyMode && attemptsLeft >= 3) || message === "TIME OUT") {
                isGameOver = true;
                const randomIndex = Math.floor(Math.random() * gameOverMessages.length);
                feedbackMessage = gameOverMessages[randomIndex];
                showFeedback(feedbackMessage, 'failure');
                
                const randomGameOverSound = gameOverSounds[Math.floor(Math.random() * gameOverSounds.length)];
                gameOverSynth.triggerAttackRelease(randomGameOverSound.notes, randomGameOverSound.duration);
                
                setTimeout(() => {
                    resetGame();
                }, 2000); 
            } else {
                 const randomIndex = Math.floor(Math.random() * singleFailureMessages.length);
                 feedbackMessage = singleFailureMessages[randomIndex];
                 showFeedback(feedbackMessage, 'failure');
                 
                 const randomErrorSound = errorSounds[Math.floor(Math.random() * errorSounds.length)];
                 errorSynth.triggerAttackRelease(randomErrorSound.note, randomErrorSound.duration);
                 
                 playerProgress = [];
                 
                 setTimeout(() => {
                     startNodeColor = '#238636';
                     endNodeColor = '#238636';
                     draw();
                     isGameActive = true;
                     startTimer();
                 }, 500); 
            }
        }
        
        startButton.addEventListener('click', () => {
            if (Tone.context.state !== 'running') {
                Tone.start();
            }

            const randomButtonSound = buttonSounds[Math.floor(Math.random() * buttonSounds.length)];
            buttonSynth.triggerAttackRelease(randomButtonSound.note, randomButtonSound.duration);
            
            // Скрываем подсказки в режиме CYBERTECH
            if (isCrazyMode) {
                 tipsContainer.classList.add('hidden');
            } else {
                 stopTips();
                 tipsContainer.classList.remove('hidden');
            }
            
            cybertechText.classList.add('hidden');
            secretMessage.style.display = 'none';
            secretMessage.textContent = '';
            
            startButton.classList.add('hidden');
            
            if (!infoElementsVisible) {
                infoPanel.classList.remove('hidden');
                let delay = 0;
                const textElements = document.querySelectorAll('.fade-in');
                textElements.forEach(el => {
                    setTimeout(() => el.classList.add('visible'), delay);
                    delay += 200;
                });
                infoElementsVisible = true;
            }

            canvas.style.display = 'block';
            bgCanvas.style.display = 'block';
            canvasWrapper.classList.add('active');
            bgCanvas.classList.add('grid-visible');

            isGameActive = true;
            resizeGame(); // Повторный вызов для исправления масштаба после появления инфо-панели
            startTimer();
            startBackgroundAnimation();
            draw();
        });
        
        exitButton.addEventListener('click', () => {
            // Очищаем интервал мигания
            clearInterval(blinkingInterval);
            resetGame();
        });
        
        // Обработчик события для нажатия на CYBERTECH
        function handleCybertechClick() {
            if (cybertechClickCount === 0) {
                tipsContainer.textContent = "ЭТО ТОГО НЕ СТОИТ";
            } else if (cybertechClickCount === 1) {
                tipsContainer.textContent = "ПРЕКРАТИТЕ СЛЕДОВАТЬ ПРОТИВ ПРАВИЛ";
            } else if (cybertechClickCount === 2) {
                tipsContainer.textContent = "ТЕПЕРЬ ВЫ ДОВОЛЬНЫ?";
                isReversed = true;
                isCrazyMode = true;
                
                // Начинаем с последнего уровня в режиме CYBERTECH
                currentLevel = levels.length - 1;
                attemptsLeft = 0; // В режиме CYBERTECH у нас 0 попыток, и они растут
                
                updateAllText();
                
                setTimeout(() => {
                    secretMessage.style.display = 'block';
                    showBinaryMessage();
                    stopTips();
                    tipsContainer.classList.add('hidden');
                    loadLevel(currentLevel); // Загружаем пятый уровень
                }, 1500); 
                
                cybertechText.removeEventListener('click', handleCybertechClick);
            }
            
            cybertechClickCount++;
        }
        
        cybertechText.addEventListener('click', handleCybertechClick);

        canvas.addEventListener('mousedown', (e) => {
            if (!isGameActive || isTracing || isGameOver) return;
            const rect = canvas.getBoundingClientRect();
            const scale = canvas.width / rect.width;
            const pos = { x: (e.clientX - rect.left) * scale, y: (e.clientY - rect.top) * scale };
            
            let startedFromNode = false;

            if (isInsideCircle(pos, startNode, nodeRadius)) {
                isTracing = true;
                playerProgress = [pos];
                traceEndNode = endNode;
                startedFromNode = true;
                startNodeColor = '#FFFFFF';
            } else if (isInsideCircle(pos, endNode, nodeRadius)) {
                isTracing = true;
                playerProgress = [pos];
                traceEndNode = startNode;
                startedFromNode = true;
                endNodeColor = '#FFFFFF';
            }
            
            if (startedFromNode) {
                draw();
            } else {
                handleFailure('INVALID START');
            }
        });

        canvas.addEventListener('mouseup', () => {
            if (isTracing) {
                handleFailure('SIGNAL LOST');
            }
        });
        
        canvas.addEventListener('mouseout', () => {
            if (isTracing) {
                handleFailure('SIGNAL LOST');
            }
        });

        canvas.addEventListener('mousemove', (e) => {
            if (!isTracing || isGameOver) return;

            // Временное отключение проверки трассировки для Уровня 5 (индекс 4)
            // Чтобы включить проверку, удалите или закомментируйте следующий блок "if".
            if (currentLevel !== 4) {
                 const rect = canvas.getBoundingClientRect();
                 const scale = canvas.width / rect.width;
                 const pos = { x: (e.clientX - rect.left) * scale, y: (e.clientY - rect.top) * scale };

                 const currentTolerance = levelTolerances[currentLevel];
                 ctx.lineWidth = currentTolerance * 2;
            
                 if (!ctx.isPointInStroke(path, pos.x, pos.y)) {
                     handleFailure('OFF TRACK');
                     return;
                 }
                 playerProgress.push(pos);
            } else {
                 const rect = canvas.getBoundingClientRect();
                 const scale = canvas.width / rect.width;
                 const pos = { x: (e.clientX - rect.left) * scale, y: (e.clientY - rect.top) * scale };
                 playerProgress.push(pos);
            }
            
            const rect = canvas.getBoundingClientRect();
            const scale = canvas.width / rect.width;
            const pos = { x: (e.clientX - rect.left) * scale, y: (e.clientY - rect.top) * scale };

            if (isInsideCircle(pos, traceEndNode, nodeRadius) && playerProgress.length > 50) {
                isTracing = false;
                isGameActive = false;
                clearInterval(timerInterval);
                
                // Очищаем предыдущий интервал мигания, если он есть
                clearInterval(blinkingInterval);

                let bonusTime = 0;
                // Проверяем, если это последний уровень
                if (currentLevel === levels.length - 1) {
                    
                    if (perfectRun) {
                        // Идеальное прохождение: чередуем текст
                        let isAnalysisText = true;
                        blinkingInterval = setInterval(() => {
                            if (isAnalysisText) {
                                completionMessage.textContent = isReversed ? reverseString("АНАЛИЗ ЗАВЕРШЁН") : "АНАЛИЗ ЗАВЕРШЁН";
                            } else {
                                completionMessage.textContent = isReversed ? reverseString("ДОСТУПНА ПРИВИЛЕГИЯ") : "ДОСТУПНА ПРИВИЛЕГИЯ";
                            }
                            isAnalysisText = !isAnalysisText;
                        }, 1000); // Быстрое переключение
                        completionMessage.classList.add('alternating-text');
                    } else {
                        // Обычное прохождение: просто мигает "АНАЛИЗ ЗАВЕРШЁН"
                        completionMessage.textContent = isReversed ? reverseString("АНАЛИЗ ЗАВЕРШЁН") : "АНАЛИЗ ЗАВЕРШЁН";
                        completionMessage.classList.remove('alternating-text');
                        completionMessage.style.animation = 'blinker-standard 1s step-end infinite';
                    }

                    setTimeout(() => {
                        completionMessageContainer.classList.remove('hidden');
                        canvas.style.display = 'none';
                        bgCanvas.style.display = 'none';
                        startButton.classList.add('hidden');
                        infoPanel.classList.add('hidden');
                        timerAndAttempts.classList.add('hidden');
                        canvasWrapper.classList.remove('active');
                        bgCanvas.classList.remove('grid-visible');
                    }, 500); // Небольшая задержка, чтобы избежать "двойных" сообщений
                    return; // Выходим, чтобы не запускать логику следующего уровня
                }

                // Бонус за идеальное прохождение в обычном режиме
                if (!isCrazyMode && attemptsLeft === 3) {
                     bonusTime = 3;
                     playBonusSound();
                     showFeedback('ПРОЙДЕНО<br>БОНУС +3 СЕК', 'success');
                // Бонус за идеальное прохождение в "сумасшедшем" режиме
                } else if (isCrazyMode && attemptsLeft === 0) {
                     bonusTime = -3;
                     playBonusSound();
                     showFeedback('ПРОЙДЕНО<br>БОНУС -3 СЕК', 'success');
                } else {
                    playSuccessSound();
                    showFeedback('ПРОЙДЕНО', 'success');
                }
                
                // Изменяем логику прогресса уровня в зависимости от режима
                if (isCrazyMode) {
                    currentLevel--;
                } else {
                    currentLevel++;
                }

                startNodeColor = '#FFFFFF';
                endNodeColor = '#FFFFFF';
                draw();
                stopBackgroundAnimation();
                
                setTimeout(() => {
                    loadLevel(currentLevel, bonusTime);
                    resizeGame(); // Вызываем масштабирование при загрузке нового уровня
                }, 2000);
            }
            
            draw();
        });

        // Запуск игры сразу с 1-го уровня (индекс 0)
        currentLevel = 0;
        attemptsLeft = 3;
        loadLevel(currentLevel);
    </script>
</body>
</html>
